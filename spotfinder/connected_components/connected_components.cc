#include "connected_components.hpp"

#include <builtin_types.h>

#include <boost/graph/adjacency_list.hpp>
#include <boost/graph/connected_components.hpp>
#include <cstdint>
#include <vector>

#include "common.hpp"
#include "cuda_common.hpp"
#include "h5read.h"

ConnectedComponents::ConnectedComponents(const uint8_t *result_image,
                                         const pixel_t *original_image,
                                         const ushort width,
                                         const ushort height,
                                         const uint32_t min_spot_size)
    : width(width),
      height(height),
      min_spot_size(min_spot_size),
      num_strong_pixels(0),
      num_strong_pixels_filtered(0) {
    // Construct signals
    size_t k = 0;  // Linear index for the image
    for (uint y = 0; y < height; ++y) {
        for (uint x = 0; x < width; ++x, ++k) {
            if (result_image[k]) {  // Store only non-zero (signal) pixels
                px_coords.emplace_back(x, y);
                px_values.push_back(original_image[k]);
                px_kvals.push_back(k);
                ++num_strong_pixels;
            }
        }
    }

    // Find connected components
    auto graph = build_graph();
    auto labels = std::vector<int>(boost::num_vertices(graph));
    auto num_labels = boost::connected_components(graph, labels.data());

    // Generate bounding boxes
    generate_boxes(labels, num_labels);
}

/**
 * Build a graph from the pixel coordinates
 * 
 * The graph is built by iterating over the pixel coordinates and connecting
 * pixels that are adjacent to each other.
 */
boost::adjacency_list<boost::vecS, boost::vecS, boost::undirectedS>
ConnectedComponents::build_graph() const {
    // Build graph
    auto graph = boost::adjacency_list<boost::vecS, boost::vecS, boost::undirectedS>{};

    // Index for next pixel to search when looking for pixels
    // below the current one. This will only ever increase, because
    // we are guaranteed to always look for one after the last found
    // pixel.
    int idx_pixel_below = 1;

    for (int i = 0; i < static_cast<int>(px_coords.size()) - 1; ++i) {
        auto coord = px_coords[i];
        auto coord_right = int2{coord.x + 1, coord.y};
        auto k = px_kvals[i];

        if (px_coords[i + 1] == coord_right) {
            // Since we generate strong pixels coordinates horizontally,
            // if there is a pixel to the right then it is guaranteed
            // to be the next one in the list. Connect these.
            boost::add_edge(i, i + 1, graph);
        }
        // Now, check the pixel directly below this one. We need to scan
        // to find it, because _if_ there is a matching strong pixel,
        // then we don't know how far ahead it is in the coordinates array
        if (coord.y < height - 1) {
            auto coord_below = int2{coord.x, coord.y + 1};
            auto k_below = k + width;
            // int idx = i + 1;
            while (idx_pixel_below < px_coords.size() - 1
                   && px_kvals[idx_pixel_below] < k_below) {
                ++idx_pixel_below;
            }
            // Either we've got the pixel below, past that - or the
            // last pixel in the coordinate set.
            if (px_coords[idx_pixel_below] == coord_below) {
                boost::add_edge(i, idx_pixel_below, graph);
            }
        }
    }

    return graph;
}

/**
 * Generate bounding boxes from the connected components
 * 
 * The bounding boxes are generated by iterating over the labels and pixel
 * coordinates and updating the bounding box for each label.
 */
void ConnectedComponents::generate_boxes(std::vector<int> labels, int num_labels) {
    // Initialize bounding boxes
    boxes = std::vector<Reflection>(num_labels, {width, height, 0, 0});

    // Update bounding boxes
    for (int i = 0; i < labels.size(); ++i) {
        auto label = labels[i];
        auto coord = px_coords[i];
        Reflection &box = boxes[label];
        box.l = std::min(box.l, coord.x);
        box.r = std::max(box.r, coord.x);
        box.t = std::min(box.t, coord.y);
        box.b = std::max(box.b, coord.y);
        box.num_pixels += 1;
    }
}