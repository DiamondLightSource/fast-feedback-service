#include "connected_components.hpp"

#include <builtin_types.h>

#include <boost/graph/adjacency_list.hpp>
#include <boost/graph/connected_components.hpp>
#include <cstdint>
#include <vector>

#include "common.hpp"
#include "cuda_common.hpp"
#include "h5read.h"

ConnectedComponents::ConnectedComponents(const uint8_t *result_image,
                                         const pixel_t *original_image,
                                         const ushort width,
                                         const ushort height,
                                         const uint32_t min_spot_size)
    : num_strong_pixels(0), num_strong_pixels_filtered(0) {
    // Construct signals
    size_t k = 0;  // Linear index for the image
    for (int y = 0; y < height; ++y) {
        for (int x = 0; x < width; ++x, ++k) {
            if (result_image[k]) {  // Store only non-zero (signal) pixels
                int2 coord{x, y};
                signals[k] = {coord, original_image[k], k};
                ++num_strong_pixels;
            }
        }
    }

    // Build graph
    build_graph(width, height);

    // Generate bounding boxes
    generate_boxes(width, height, min_spot_size);
}

/**
 * Build a graph from the pixel coordinates
 * 
 * The graph is built by iterating over the pixel coordinates and connecting
 * pixels that are adjacent to each other.
 */
void ConnectedComponents::build_graph(const ushort width, const ushort height) {
    // Map linear_index to vertex ID for graph consistency
    size_t vertex_id = 0;

    // First, add vertices to the graph
    for (const auto &[linear_index, signal] : signals) {
        vertex_map[linear_index] = vertex_id++;
        boost::add_vertex(graph);
    }

    // Add edges by checking neighbors
    for (const auto &[linear_index, signal] : signals) {
        size_t right_linear_index = linear_index + 1;      // Pixel to the right
        size_t below_linear_index = linear_index + width;  // Pixel below

        // Check and connect to the pixel on the right
        if (signals.find(right_linear_index) != signals.end()) {
            boost::add_edge(
              vertex_map[linear_index], vertex_map[right_linear_index], graph);
        }

        // Check and connect to the pixel below
        if (signals.find(below_linear_index) != signals.end()) {
            boost::add_edge(
              vertex_map[linear_index], vertex_map[below_linear_index], graph);
        }
    }
}

/**
 * Generate bounding boxes from the connected components
 * 
 * The bounding boxes are generated by iterating over the labels and pixel
 * coordinates and updating the bounding box for each label.
 */
void ConnectedComponents::generate_boxes(const ushort width,
                                         const ushort height,
                                         const uint32_t min_spot_size) {
    auto labels = std::vector<int>(boost::num_vertices(graph));
    auto num_labels = boost::connected_components(graph, labels.data());

    // Initialize bounding boxes
    boxes = std::vector<Reflection>(num_labels, {width, height, 0, 0});

    // Iterate over the signals and update the bounding boxes
    for (const auto &[linear_index, signal] : signals) {
        // Retrieve the vertex index for this linear_index (linear_index -> vertex_id in build_graph)
        auto vertex_it = vertex_map.find(linear_index);
        if (vertex_it == vertex_map.end()) {
            throw std::runtime_error("Vertex not found in vertex_map");
        }

        size_t vertex_id = vertex_it->second;  // Vertex ID in the graph
        int label = labels[vertex_id];         // Label assigned to this vertex

        auto &box = boxes[label];
        box.l = std::min(box.l, signal.coord.x);
        box.r = std::max(box.r, signal.coord.x);
        box.t = std::min(box.t, signal.coord.y);
        box.b = std::max(box.b, signal.coord.y);
        ++box.num_pixels;  // Increment the number of pixels in the box
    }

    // Filter boxes based on the minimum spot size
    if (min_spot_size > 0) {
        std::vector<Reflection> filtered_boxes;
        for (auto &box : boxes) {
            if (box.num_pixels >= min_spot_size) {
                filtered_boxes.emplace_back(box);
                num_strong_pixels_filtered += box.num_pixels;
            }
        }
        // Overwrite boxes with filtered boxes
        boxes = std::move(filtered_boxes);
    } else {
        num_strong_pixels_filtered = num_strong_pixels;
    }
}

std::vector<Reflection3D> ConnectedComponents::find_3d_components(
  const std::vector<std::unique_ptr<ConnectedComponents>> &slices,
  const ushort width,
  const ushort height) {
    /*
     * Initialize global containers for the 3D connected components
     */
    printf("Initializing 3D connected components...\n");
    // Graph for the 3D connected components
    boost::adjacency_list<boost::vecS, boost::vecS, boost::undirectedS> graph_3d;
    // List to store each slice's mapping of linear_index -> global_vertex_id
    std::vector<std::unordered_map<size_t, size_t>> local_to_global_vertex_maps;
    // Global vertex ID counter starts at 0 and increments for each new vertex
    size_t global_vertex_id = 0;

    /*
     * Start building the 3D graph. First we copy the precomputed vertices and edges
     * from each slice's graph into the global 3D graph.
     */
    printf("Building 3D graph...\n");
    for (const auto &slice : slices) {
        // Get the slice's graph and vertex map
        const auto &graph = slice->get_graph();
        const auto &signals = slice->get_signals();

        // 2D linear_index -> global_vertex_id map for this slice
        std::unordered_map<size_t, size_t> local_to_global;

        // Add each vertex from the slice's graph to the global graph
        for (const auto &[linear_index, signal] : signals) {
            // Add the vertex to the global graph
            local_to_global[linear_index] = global_vertex_id++;
            boost::add_vertex(graph_3d);
        }

        // Move the local_to_global map to the global list
        local_to_global_vertex_maps.push_back(std::move(local_to_global));
    }

    /*
     * We then copy the pre-computed edges from each slice's graph to the 3D graph.
     */
    printf("Copying edges to 3D graph...\n");
    // Iterate over each slice and copy the edges to the 3D graph
    for (int i = 0; i < slices.size(); ++i) {
        const auto &working_graph = slices[i]->get_graph();  // Get the slice's graph
        const auto &working_vertex_map =
          slices[i]->get_vertex_map();  // Get the slice's vertex map

        std::unordered_map<size_t, size_t> reverse_vertex_map;
        for (const auto &[linear_index, vertex_id] : working_vertex_map) {
            reverse_vertex_map[vertex_id] = linear_index;
        }

        printf("Copying edges from slice %d...\n", i);
        // Iterate over the edges in the slice's graph
        for (const auto &edge :
             boost::make_iterator_range(boost::edges(working_graph))) {
            // Get the source and target vertices for the edge
            auto source_vertex = boost::source(edge, working_graph);
            auto target_vertex = boost::target(edge, working_graph);

            // Retrieve the original linear indices
            size_t source_linear_index = reverse_vertex_map[source_vertex];
            size_t target_linear_index = reverse_vertex_map[target_vertex];

            // Get the global vertex IDs
            size_t source_global_id =
              local_to_global_vertex_maps[i][source_linear_index];
            size_t target_global_id =
              local_to_global_vertex_maps[i][target_linear_index];

            // Add the edge to the 3D graph
            boost::add_edge(source_global_id, target_global_id, graph_3d);
        }
    }

    /*
     * Next, we add inter-slice connectivity to the 3D graph. This is done by
     * iterating over the local_to_global_vertex_maps and connecting vertices
     * that correspond to the same pixel in adjacent slices.
     */
    printf("Adding inter-slice connectivity...\n");
    // Loop through all slices except the last one
    for (size_t i = 0; i < slices.size() - 1; ++i) {
        const auto &current_vertex_map =
          local_to_global_vertex_maps[i];  // Current slice
        const auto &next_vertex_map = local_to_global_vertex_maps[i + 1];  // Next slice

        // Iterate over the vertices in the current slice
        for (const auto &[current_linear_index, current_global_id] :
             current_vertex_map) {
            // Check if the corresponding vertex exists in the next slice
            auto iterated_vertex = next_vertex_map.find(current_linear_index);
            // If it exists, connect the vertices in the 3D graph
            if (iterated_vertex != next_vertex_map.end()) {
                // Connect the vertices in the 3D graph
                size_t next_global_id =
                  iterated_vertex->second;  // Get the global id from the vertex map
                boost::add_edge(current_global_id, next_global_id, graph_3d);
            }
        }
    }

    /*
     * Now that we have constructed the 3D graph, we can perform connected components
     * analysis to find the 3D connected components.
     */
    printf("Performing 3D connected components analysis...\n");
    std::vector<int> labels(
      boost::num_vertices(graph_3d));  // Label vector for connected components
    uint num_labels = boost::connected_components(
      graph_3d, labels.data());  // Find connected components

    /*
     * Group the 3D connected components by their labels and compute the bounding boxes
     * and weighted centers of mass for each component. We do this by creating a map
     * of labels to vectors of global vertex IDs, and then iterating over each map
     * entry to compute the bounding box and center of mass.
     */
    printf("Grouping 3D connected components...\n");
    std::vector<Reflection3D> reflections_3d(
      num_labels);  // List to store 3D reflections

    std::unordered_map<int, std::vector<size_t>>
      label_to_vertices;  // Map of labels -> global vertices for each label
    for (int i = 0; i < labels.size(); ++i) {
        label_to_vertices[labels[i]].push_back(
          i);  // Add the vertex to the label's list
    }

    // TODO: Implement bounding box and center of mass computation

    return reflections_3d;
}
