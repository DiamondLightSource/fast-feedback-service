#include "connected_components.hpp"

#include <builtin_types.h>

#include <boost/graph/adjacency_list.hpp>
#include <boost/graph/connected_components.hpp>
#include <cstdint>
#include <vector>

#include "common.hpp"
#include "cuda_common.hpp"
#include "h5read.h"

ConnectedComponents::ConnectedComponents(const uint8_t *result_image,
                                         const pixel_t *original_image,
                                         const ushort width,
                                         const ushort height,
                                         const uint32_t min_spot_size)
    : width(width),
      height(height),
      min_spot_size(min_spot_size),
      num_strong_pixels(0),
      num_strong_pixels_filtered(0) {
    // Construct signals
    size_t k = 0;  // Linear index for the image
    for (int y = 0; y < height; ++y) {
        for (int x = 0; x < width; ++x, ++k) {
            if (result_image[k]) {  // Store only non-zero (signal) pixels
                int2 coord{x, y};
                signals[k] = {coord, original_image[k], k};
                ++num_strong_pixels;
            }
        }
    }

    // Build graph
    auto graph = build_graph();

    // Find connected components
    auto labels = std::vector<int>(boost::num_vertices(graph));
    auto num_labels = boost::connected_components(graph, labels.data());

    // Generate bounding boxes
    generate_boxes(labels, num_labels);
}

/**
 * Build a graph from the pixel coordinates
 * 
 * The graph is built by iterating over the pixel coordinates and connecting
 * pixels that are adjacent to each other.
 */
boost::adjacency_list<boost::vecS, boost::vecS, boost::undirectedS>
ConnectedComponents::build_graph() {
    // Graph to store connected components
    auto graph = boost::adjacency_list<boost::vecS, boost::vecS, boost::undirectedS>{};

    // Map linear_index to vertex ID for graph consistency
    size_t vertex_id = 0;

    // First, add vertices to the graph
    for (const auto &[linear_index, signal] : signals) {
        vertex_map[linear_index] = vertex_id++;
        boost::add_vertex(graph);
    }

    // Add edges by checking neighbors
    for (const auto &[linear_index, signal] : signals) {
        size_t right_linear_index = linear_index + 1;      // Pixel to the right
        size_t below_linear_index = linear_index + width;  // Pixel below

        // Check and connect to the pixel on the right
        if (signals.find(right_linear_index) != signals.end()) {
            boost::add_edge(
              vertex_map[linear_index], vertex_map[right_linear_index], graph);
        }

        // Check and connect to the pixel below
        if (signals.find(below_linear_index) != signals.end()) {
            boost::add_edge(
              vertex_map[linear_index], vertex_map[below_linear_index], graph);
        }
    }

    return graph;
}

/**
 * Generate bounding boxes from the connected components
 * 
 * The bounding boxes are generated by iterating over the labels and pixel
 * coordinates and updating the bounding box for each label.
 */
void ConnectedComponents::generate_boxes(std::vector<int> labels, int num_labels) {
    // Initialize bounding boxes
    boxes = std::vector<Reflection>(num_labels, {width, height, 0, 0});

    // Iterate over the signals and update the bounding boxes
    for (const auto &[linear_index, signal] : signals) {
        // Retrieve the vertex index for this linear_index (linear_index -> vertex_id in build_graph)
        auto vertex_it = vertex_map.find(linear_index);
        if (vertex_it == vertex_map.end()) {
            throw std::runtime_error("Vertex not found in vertex_map");
        }

        size_t vertex_id = vertex_it->second;  // Vertex ID in the graph
        int label = labels[vertex_id];         // Label assigned to this vertex

        auto &box = boxes[label];
        box.l = std::min(box.l, signal.coord.x);
        box.r = std::max(box.r, signal.coord.x);
        box.t = std::min(box.t, signal.coord.y);
        box.b = std::max(box.b, signal.coord.y);
        ++box.num_pixels;  // Increment the number of pixels in the box
    }

    // Filter boxes based on the minimum spot size
    if (min_spot_size > 0) {
        std::vector<Reflection> filtered_boxes;
        for (auto &box : boxes) {
            if (box.num_pixels >= min_spot_size) {
                filtered_boxes.emplace_back(box);
                num_strong_pixels_filtered += box.num_pixels;
            }
        }
        // Overwrite boxes with filtered boxes
        boxes = std::move(filtered_boxes);
    } else {
        num_strong_pixels_filtered = num_strong_pixels;
    }
}