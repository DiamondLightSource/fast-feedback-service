# h5read

Designed to be a common utility c and library for reading nexus hdf5 files
from miniapp implementations. This is intended to help remove differences
between parsing of image files between implementations.

There are both [C](#reference---c-api) and [C++](#reference---c-api-1) API
interfaces to the library.

## Usage

Add this directory as a subdirectory in your `CMakeLists.txt`:

```cmake
add_subdirectory(../h5read h5read)
```

And then add as a dependency to your built targets:

```cmake
target_link_libraries(${target_name} PUBLIC h5read)
```

All manipulation and data access happens via an opaque `h5read_handle` object.
The easiest way to create an `h5read_handle` is to use the provided argument
parser:

```c
h5read_handle *obj = h5read_parse_standard_args(argc, argv);
```

This will parse any argument for your program as:

```
Usage: your_program [-h|--help] [-v] [FILE.nxs | --sample]


Options:
  FILE.nxs      Path to the Nexus file to parse
  -h, --help    Show this message
  -v            Verbose HDF5 message output
  --sample      Don't load a data file, instead use generated test data
```

## Generated Sample Data

Currently, the sample data generated by passing `--sample` or calling
`h5read_generate_samples()` are Eiger 2XE 16Mp data, with 1028x512px modules,
12x38px gaps and a total image size of 4363x4148px. There is a mask present
which masks off the module gap but otherwise is empty.

The intention is to provide a baseline of simple, known images to do validation
from.

| Index | Description                                                                                               |
| ----- | --------------------------------------------------------------------------------------------------------- |
| 0     | Completely empty image. This means 16842752 valid, empty pixels.                                          |
| 1     | I=1 for every unmasked pixel                                                                              |
| 2     | Single pixels of I=100, every 42 pixels in a grid, for 10296 total. Of these pixels, 9604 are not masked. |

## Reference - C API

### Handle Creation

```c
h5read_handle *h5read_open(const char *master_filename)
```

Open a Nexus file, and return an opaque `h5read_handle` pointer. This must be
released by calling `h5read_free` when it is no longer required. If the
function cannot open a root nexus file, it will return `NULL`.

If the function can open the base file but encounters an error reading the
child files or datasets (including unexpected data shapes), then it will print
a message to stderr and `exit(1)`. These error cases may be changed to a return
of `NULL` in the future.

This function is somewhat limited in the Nexus files that it will accept - it
will try to accept Eiger 2XE 4M and 16M data, but can not currently accept
other shaped detectors.

---

```c
h5read_handle *h5read_generate_samples();
```

Doesn't open a Nexus file, but instead return an `h5read_handle` that accesses
a set of generated sample data, as described in [Generated Sample
Data](#generated-sample-data) of data. This also needs to be released by
calling `h5read_free` when it is no longer required.

---

```c
h5read_handle *h5read_parse_standard_args(int argc, char **argv)
```

Parse an arc/argv pair of command line arguments. This will accept a filename,
or a request to use sample data with `--sample`. If there is an error reading
the nexus file, then this will call `exit(1)`, so the returned handle from this
function will always be valid.

---

```c
h5read_free(h5read_handle *)
```

Frees a previously constructed handle object. It is an error to release these
resources without first releasing all image data - the image objects may
hold references to data held in the master object.

---

### Image Information

```c
size_t h5read_get_number_of_images(h5read_handle *obj);
```

Get the number of images in a particular dataset

---

```c
size_t h5read_get_image_slow(h5read_handle *obj);
```

Get the number of image pixels in the slow dimension

---

```c
size_t h5read_get_image_fast(h5read_handle *obj);
```

Get the number of image pixels in the fast dimension

---

### Image Data

Image Data is represented in the form of a struct:

```c
typedef struct image_t {
    uint16_t *data;
    uint8_t *mask;
    size_t slow;
    size_t fast;
} image_t;
```

Where `slow` and `fast` are the image dimensions, in pixels, and `data`
and `mask` are pointers to 2D arrays of image data. For convenience,
`image_t_type` is defined in `h5read.h` to point to the data type used for
image data.

You can retrieve an image struct for a particular image with:

```c
image_t *h5read_get_image(h5read_handle *obj, size_t frame_number);
```

If the library cannot read the image, it will print an error message and
call `exit(1)`.

When you are finished with the image, you can release it by calling:

```
void h5read_free_image(image_t *image);
```

### Image Modules Data

For convenience, you can also access image data in the form of single modules.
Modules are represented by the `image_modules_t` struct:

```c
typedef struct image_modules_t {
    uint16_t *data;  ///< Module image data; 3D array of [module][slow][fast]
    uint8_t *mask;   ///< Image mask, in the same shape as the module data
    size_t modules;  ///< Total number of modules
    size_t slow;     ///< Number of pixels in slow direction per module
    size_t fast;     ///< Number of pixels in fast direction per module
} image_modules_t;

```

This can be retrieved with:

```c
image_modules_t *h5read_get_image_modules(h5read_handle *obj, size_t frame_number);
```

Like `h5read_get_image`, this function will call `exit(1)` with an error
message if it fails to load the image data.

This `image_modules_t` object should be released after usage by calling:

```c
void h5read_free_image_modules(image_modules_t *modules);
```

## Reference - C++ API

Alongside the C api, there is also C++ API in `#include "h5read.h"`. This
mostly takes the same form, but takes care of memory management for you.

### Creating Reader Objects

Instead of creating an handle pointer, You create an `H5Read` class. This has
three constructor forms:

```C++
H5Read()
```

Constructs the reader with sample data, as via `h5read_generate_samples`.

```C++
H5Read(const std::string &filename)
```

Constructs a reader from a physical Nexus file. Any way that the `h5read_open`
could fail by returning a null pointer, this will raise an
`std::runtime_error`.

```C++
H5Read(int argc, char **argv);
```

Construct a reader by interpreting command-line arguments, the same as
`h5read_parse_standard_args`.

Once you have an `H5Read` object, you can retrieve information via:

```C++
size_t get_number_of_images();     // Get the number of frames in the reader
size_t get_image_slow();   // Get the number of pixels in the slow dimension
size_t get_image_fast();   // Get the number of pixels in the fast dimension
std::array<size_t, 2> image_shape(); // Get the image shape, in (slow, fast)
```

### Image Data

To access an image, you can use:

```C++
Image H5Read::get_image(size_t index)
```

This will return an `Image` object. Much like the `image_t` struct, this contains
members pointing to the various data:

```C++
struct Image {
    image_t_type *const data; // Pointer to image data
    uint8_t *const mask;      // Pointer to mask data
    const size_t slow;        // Number of y (slow) pixels
    const size_t fast;        // Number of x (fast) pixels
}
```

### Image Modules Data

To access an image in the form of separate modules, you can use:

```C++
ImageModules H5Read::get_image_modules(size_t index)
```

This returns an object with image data in the form of a modules array:

```
struct ImageModules {
    image_t_type *const data;
    uint8_t *const mask;

    const size_t n_modules;  // Number of modules
    const size_t slow;       // Height of a module, in pixels
    const size_t fast;       // Width of a module, in pixels

    image_t_type *const *const modules;
    uint8_t *const *const masks;
}
```

`.data` and `.mask` are the same as `image_modules_t` - a pointer to the entire
array of data for all modules.

In addition, for convenience, there are the `.modules` and `.masks` lookup
arrays - these are arrays that point to each module separately, so one can
access a single module by e.g.

```C++
image_t_type *module = modules.modules[1];
```

(This was slightly cleaner in an earlier implementation that used `std::span`,
however C++20 does not seem available everywhere that dpcpp was, so perhaps it
is unfortunately a little early to require C++20 support.)

Unlike the C api, it is safe to keep these objects around longer than the main
`H5Read` object.
